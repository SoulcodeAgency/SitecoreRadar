---
name: Headless Architecture # this is the Title of your Blip
ring: Trial # Values: [Hold | Assess | Trial | Adopt]
quadrant: Techniques # Values: [Tools-And-Libraries | Techniques | Modules | Products] - Make sure to keep these exact values, the Radar is also case sensitive.
isNew: TRUE # Values: [TRUE | FALSE] - Make sure to keep the value all uppercase.
---
A headless architecture in a content management context is not new. It's a proven and widely accepted architectural pattern with its own pros and cons. But is this a technique that should be persued when creating experiences with Sitecore?

There are multiple options to consume content through a RESTful API with Sitecore. With the latest addition Sitecore dedicates a full documentation chapter on [headless development with Sitecore](https://doc.sitecore.com/developers/100/developer-tools/en/sitecore-headless-development.html). This chapter contains the documentation around the newest kid on the block: the ASP.Net Rendering Host. But there are more options available. Namely the [JavaScript Services (JSS)](https://jss.sitecore.com/) with client SDKs for multiple popular frameworks, the new [GraphQL](https://doc.sitecore.com/developers/100/sitecore-experience-manager/en/graphql.html) API but also less widely used options like [SXA Headless](https://doc.sitecore.com/developers/sxa/100/sitecore-experience-accelerator/en/headless.html) with its own JSON rendering and the [Sitecore Services Client (SSC)](https://doc.sitecore.com/developers/100/sitecore-experience-manager/en/sitecore-services-client.html).

While all approaches provide data (or more specific: content) access over HTTP, JSS is the tool to use to implement a headless website with support for the Experience Editor, personalization and access to "page" structures and routing information. The ASP.NET Rendering Host equally allows decoupling the presentation rendering from the content delivery, but does so on the server-side. You then have the option to either respond with HTML pages rendered with a server-side view engine (typically Razor) or a custom implementation of the headless endpoint consumed by your client (most likely running in a browser). Both approaches integrate with the Layout Service that parses the layout details of items and provides access to its datasources.

If a more data-driven approach is what you're looking for, the GraphQL API might provide just what you need, currently focusing on data-read access. If you're implementation is even more data driven and requires CRUD operations, the Sitecore Services Client might suit you. That said, future development will most likely happen on the GraphQL API with a wide framework support in the JavaScript ecosystem.

Lastly there's the headless rendering provided by SXA, which should be the last option to take into account with a greenfield solution. That said, it's a nice option if you're already running an SXA site and would like to integrated some of the data through an API. Also note that JSS is supported to run inside an SXA tenant.

As a conclusion: if your team is ready and the features of the site can benefit from a headless approach, you should certainly consider one of the many options available. Headless is the architecture to move forward, so we're putting assigning this blip to the _Adopt_ ring. See the Products category for details on specific APIs offered by Sitecore.
