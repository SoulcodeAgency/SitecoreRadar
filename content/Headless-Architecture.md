---
name: Headless Architecture # this is the Title of your Blip
ring: Trial # Values: [Hold | Assess | Trial | Adopt]
quadrant: Techniques # Values: [Tools-And-Libraries | Techniques | Modules | Products] - Make sure to keep these exact values, the Radar is also case sensitive.
isNew: TRUE # Values: [TRUE | FALSE] - Make sure to keep the value all uppercase.
---
A headless architecture in a content management context is not new. It's a proven and widely accepted architectural pattern with its own pros and cons. But is this a technique that should be persued when creating experiences with Sitecore?

There are multiple options to consume content through a RESTful API with Sitecore. With the latest addition Sitecore dedicates a full documentation chapter on [headless development with Sitecore](https://doc.sitecore.com/developers/100/developer-tools/en/sitecore-headless-development.html). Strangely this chapter currently only contains the documentation around the newest kid on the block: the ASP.Net Rendering Host. But there are more options available. Namely the [JavaScript Services (JSS)](https://jss.sitecore.com/) with client SDKs for multiple popular frameworks, the new [GraphQL](https://doc.sitecore.com/developers/100/sitecore-experience-manager/en/graphql.html) API but also less widely used options like [SXA Headless](https://doc.sitecore.com/developers/sxa/100/sitecore-experience-accelerator/en/headless.html) with its own JSON rendering and the [Sitecore Services Client (SSC)](https://doc.sitecore.com/developers/100/sitecore-experience-manager/en/sitecore-services-client.html).

While all approaches provide data (or more specific: content) access over HTTP, JSS is the tool to use to implement a headless website with support for the Experience Editor, personalization and access to "page" structures and routing information. The ASP.NET Rendering Host equally allows decoupling the presentation rendering from the content delivery, but does so on the server-side. You then have the option to either respond with HTML pages rendered with a server-side view engine (typically Razor) or a custom implementation of the headless endpoint consumed by your client (most likely running in a browser). Both approaches integrate with the Layout Service that parses the layout details of items and provides access to its datasources.

If a more data-driven approach is what you're looking for, the GraphQL API might provide just what you need, currently focusing on data-read access. If you're implementation is even more data driven and requires CRUD operations, the Sitecore Services Client might suit you. That said, future development will most likely happen on the GraphQL API with a wide framework support in the JavaScript ecosystem.

Lastly there's the headless rendering provided by SXA, which should be the last option to take into account with a greenfield solution. That said, it's a nice option if you're already running an SXA site and would like to integrated some of the data through an RESTful API. Also note that JSS is supported to run inside an SXA tenant.

As a conclusion: if your team is ready and the features of the site can benefit from a headless approach, you should certainly consider one of the many options available. That said, we feel that the platform currently offers too many independently developed JSON based APIs and we expect a consolitation in the near future. This fact is holding us back from adding this technique to the Adopt ring and keeping it in the _Trial_ ring.
